# План архитектуры и миграции

## Обзор

Цель — зафиксировать целевую архитектуру и последовательность миграции от прототипа к поддерживаемой структуре, без переписывания UI/транспорта в дальнейшем.

## Слои системы

- SERVER (транспорт): MQTT (сейчас), HTTP (позже). Инкапсулирует детали брокера/URI/заголовков.
- STATE (состояние): централизованное приложение‑состояние и редьюсеры для его обновления.
- UI (представление): рендерит состояние и отправляет пользовательские действия.
- ROUTER (связка): переводит действия UI в вызовы сервисов и диспатчит события сервера в Store.

## Итоги ревью текущего прототипа

Плюсы
- Разделение транспорта и UI уже намечено, MQTT работает стабильно.
- Идея хранить состояния сущностей (Entity) централизованно — верная.

Риски
- Прямые вызовы транспорта из UI повышают связность.
- Конфиги (URI/креды/темы) зашиты макросами — трудно менять на рантайме.
- Избыточная многопоточность усложняет синхронизацию с LVGL.

## Описание 

# SERVER — внешний сервер  
- Любой источник данных (MQTT, HTTP).  
- В нашем случае — Home Assistant с MQTT.  
- Отвечает за получение и отправку сообщений о состоянии устройств.

# STATE — единое хранилище данных и состояния  
- Хранит текущее состояние всех датчиков и переключателей.  
- Содержит структуру `EntityState` для значений и общий список сущностей `EntityCfg`.  
- Отдельно хранится состояние интерфейса (текущий экран, активность и т.п.).  
- Все изменения проходят через этот слой.

# UI — визуализация состояния  
- Отдельные экраны и режим скринсейвера.  
- Отображает данные из STATE, не зная, откуда они пришли.  
- Подписывается на обновления через встроенный механизм `lv_msg`.  
- Реагирует на изменения данных и пользовательский ввод.

# ROUTER — связующий слой (медиатор)  
- Соединяет SERVER, STATE и UI.  
- Получает сообщения от SERVER и обновляет STATE.  
- Передаёт команды пользователя (toggle, set) из UI обратно на SERVER.  
- Следит за подписками, реконнектами и синхронизацией данных.


## Целевая архитектура

### Core (домен)
- Типы: `EntityId` (строка), `EntityState { id, state, attributes(json) }`, `EntityCfg { id, name }`.
- Действия/события:
  - `UiAction { Toggle(id), SelectEntity(index), Wake, Sleep }`.
  - `ServerEvent { Connected, Disconnected, StateUpdated(id, payload) }`.
- Store: один FreeRTOS‑таск с очередью `QueueHandle_t`. Редьюсер применяет события к `AppState`, уведомляет подписчиков.

### Transport (infra)
- `ITransport` — минимальный интерфейс (subscribe/publish/is_connected, handler).
- Реализации: `MqttTransport` (поверх текущего ha_mqtt), позже `HttpTransport` (на базе http_utils) — без влияния на UI.

### Service (HA‑логика)
- `HaService` знает топики/форматы, мапит входящие сообщения в `ServerEvent`, отправляет команды (`toggle`).

### Router
- Принимает `UiAction` из UI, вызывает `HaService` и диспатчит эффекты/ошибки в Store.

### UI
- Отправляет только `UiAction` и подписывается на Store‑апдейты. Все вызовы LVGL — через `lvgl_port_lock`/`lv_async_call`.

### Config
- Источники: Kconfig + NVS. Единый модуль загрузки/валидации настроек (URI/логин/пароль/темы/идентификаторы).

## Структура каталогов

```
main/
  app/            # точка входа, wiring
  ui/             # ui_app.cpp и виджеты
  core/           # модели, actions, store, reducers
  services/       # ha_service.*
  infra/transport # ha_mqtt.*, http_utils.* (адаптеры под ITransport)
  config/         # config.hpp, загрузка Kconfig/NVS
```

## Интерфейсы (черновик)

```cpp
// core/actions.hpp
enum class UiActionType { Toggle, SelectEntity, Wake, Sleep };
struct UiAction { UiActionType type; const char* entity_id; int index; };

enum class ServerEventType { Connected, Disconnected, StateUpdated };
struct ServerEvent { ServerEventType type; const char* entity_id; const char* payload; };

struct AppState { int selected; bool connected; /* + map<id, EntityState> */ };

// core/store.hpp
void store_start();
void store_dispatch_server(const ServerEvent& ev);
void store_dispatch_ui(const UiAction& act);
using StateListener = void(*)(const AppState&);
void store_subscribe(StateListener cb);

// infra/transport/i_transport.hpp
struct ITransport {
  virtual esp_err_t start() = 0;
  virtual esp_err_t publish(const char* topic, const char* payload, int qos, bool retain) = 0;
  using Handler = void(*)(const char* topic, const char* data, int len);
  virtual esp_err_t subscribe(const char* topic, int qos) = 0;
  virtual void set_handler(Handler h) = 0;
  virtual bool is_connected() const = 0;
  virtual ~ITransport() = default;
};

// services/ha_service.hpp
namespace ha { esp_err_t start(ITransport& t); esp_err_t toggle(const char* entity_id); }

// app/router.hpp
namespace router { void init(ITransport& t); void dispatch(const UiAction&); }
```

## План миграции (итерации)

1) Core/Store
- Ввести `AppState`, `UiAction`, `ServerEvent`, `store_*` API (один таск + очередь). Подписка из UI.

2) Transport‑абстракция
- Обернуть `ha_mqtt` в `MqttTransport` (реализация `ITransport`).

3) HaService
- Подписка на `ha/state/+`, маппинг в `ServerEvent::StateUpdated`. Команда `toggle(entity)` → `ha/cmd/toggle`.

4) Router
- `router::dispatch(UiAction)` вызывает `ha::toggle` и диспатчит выбор текущей сущности в Store.

5) UI интеграция
- Заменить прямые вызовы `ha_mqtt` на `router::dispatch`. Подписать UI на `store_subscribe`.

6) Config
- Перенос MQTT URI/логина/пароля в Kconfig + загрузка из NVS в `config` модуль.

7) HTTP (позже)
- Использовать `http_utils` для `HttpTransport`/`HaHttpService` без изменений в UI/Store.

## Технические заметки
- Один Store‑таск и одна очередь событий вместо множества задач.
- Синхронизация с LVGL: только через `lvgl_port_lock`/`lv_async_call`.
- Логирование: теги `app, ui, store, router, ha_service, transport`, троттлинг шумных событий.
- Редьюсеры — чистые функции, легко тестируются на хосте.

## Дорожная карта
- Итерация 1: Store + MqttTransport + HaService + Router, UI на Router.
- Итерация 2: Config/Kconfig/NVS, устранение глобалов, консолидация тем/строк.
- Итерация 3: Расширение STATE (атрибуты), подписки на несколько сущностей.
- Итерация 4: HTTP‑адаптер и сервисные вызовы при необходимости.

