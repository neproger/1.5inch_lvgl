# UI TODO: новая архитектура экранов

## 1. Структура экранов / навигация
- Получать список комнат через `state::areas()` (`g_areas`).
- Для каждой комнаты (`Area`) создавать отдельную страницу LVGL: `RoomPage`.
- Хранить массив/вектор страниц в UI: `std::vector<RoomPage> s_room_pages`.
- Поворот энкодера (`LVGL_knob_event`) листает страницы-комнаты (по индексу комнаты).
- Текущий индекс комнаты: `s_current_room_index`.
- Внутри страницы – вертикальный список/роллер устройств этой комнаты.

## 2. Привязка сущностей к комнатам
- Использовать `state::entities()` (`g_entities`), у каждой `Entity` есть `area_id`.
- При построении `RoomPage` отфильтровать `g_entities` по `entity.area_id == room.id`.
- Сохранить связи `RoomPage` → список entity-id и их LVGL-виджетов.
- При обновлении состояния (слушатель `on_state_entity_changed`) находить нужную страницу/виджет и обновлять его.

## 3. Виджеты устройств
- На каждой странице создавать вертикальный список/роллер с элементами управления или показаниями.
- Пока поддерживаем только один тип: `switch`.
  - Для switch использовать `lv_switch` + подпись имени устройства/состояния.
  - Свич знает свой `entity_id` (через пользовательские данные/структуру).
- В будущем добавить другие типы:
  - Термометр (датчик температуры).
  - Освещение с диммером.
  - Освещение с выбором цвета.
  - Другие устройства Home Assistant по мере необходимости.

## 4. Логика ввода (крутилка и кнопка)
- `LVGL_knob_event`:
  - Переключает текущую комнату (страницу) по энкодеру.
  - Внутри комнаты можно предусмотреть второй режим вращения для перемещения по списку устройств (определить позже: режимы или зоны).
- `LVGL_button_event`:
  - По короткому нажатию – переключает состояние текущего выбранного устройства.
  - Выбор «текущего устройства» определяется выделением/фокусом в роллере/списке.

## 5. Взаимодействие с MQTT / state_manager
- Кнопка НЕ меняет состояние напрямую.
- При нажатии:
  - Вызываем `router::toggle(entity_id)` для текущего устройства.
  - Не вызываем `state::set_entity_state` из UI.
- Реальное состояние приходит по MQTT и попадает в `state::set_entity_state`.
- `state::set_entity_state` дергает подписчиков (`EntityListener`), среди них UI:
  - `on_state_entity_changed` помечает соответствующий виджет «грязным» и обновляет его внешний вид.

## 6. Спиннер / состояние «ожидания»
- При старте операции переключения (до `router::toggle`) показываем индикатор ожидания:
  - Глобальный `lv_obj_t *s_spinner` (или спиннер на странице).
  - Функции `show_spinner()` / `hide_spinner()`.
- `show_spinner()`:
  - Ленивая инициализация `lv_spinner` на активном экране.
  - Центрирование или позиционирование рядом с основным статус-лейблом.
- `hide_spinner()`:
  - Прятать/удалять спиннер после того, как новое состояние реально пришло и отрисовалось (через `on_state_entity_changed`).

## 7. Подписки UI на state_manager
- При инициализации UI:
  - Для каждого `Entity` подписаться через `state::subscribe_entity(id, on_state_entity_changed)`.
  - Сохранить IDs подписок в `s_state_subscriptions`.
- В `on_state_entity_changed`:
  - Найти соответствующий `RoomPage` и виджет.
  - Обновить отображение (состояние свича/текста).
  - При первом успешном обновлении состояния – вызвать `hide_spinner()`.

## 8. Переход от старого UI
- Удалить/переписать жестко зашитые экраны `Kitchen`, `Hallway`, `ScreenSaver`.
- Вместо ручных экранов – динамический список страниц по `state::areas()`.
- Сохранить/перенести полезную логику:
  - Status ring и индикацию MQTT-соединения.
  - Screensaver (отдельный экран или overlay).
  - Логику тайм-аута `SCREENSAVER_TIMEOUT_US`.

